# boris-compiler

> From NYU CS-UY3943 BK06/CS-GY6413: Compiler Design & Construction.

The project involves building several stages of a complete compiler for a made-up language made by Prof **Boris Aronov**. 


The following parts will be necessary:

- a scanner 
- a parser and symbol table handler
- a type checker
- a code generator

## scanner

The scanner (or to be mentioned as lexer) is used to use REGEX expression to recognize tokens in the input text.

The standalone scanner is in branch 'scanner' now. 

The rule to recognize tokens didn't change. Some behavior and logic has been changed in `master` branch. It can be tested and developed in this branch. In the master brance, the scanner is rewrited in a better practice to interact with `bison` codes. 

The scanner is generated by using `flex`.

- Build the scanner

~~~ bash
>> git checkout scanner
>> make scanner
~~~

- Run tests

~~~ bash
>> cat tests/p1test1.txt | ./boris_scanner >> tests/p1test1.out
~~~
~~~
[Warning]INT_LIT in a invalid format. Non-zero integer can't start with 0. No guarantee what will happen. in Line 43, [1,3]
[Warning]The length of INT_LIT exceeds max length, No guarantee what will happen. in Line 47, [1,22]
[Warning]The length of INT_LIT exceeds max length, No guarantee what will happen. in Line 49, [1,22]
[Warning]The length of ID exceeds max length, ID will be truncated. in Line 59, [1,93]
~~~
~~~ bash
>> cat tests/p1test1.out
~~~
~~~
[Token 297] in Line 1, [1,75].
[Token 299] in Line 2, [0,0].
[Token 297] in Line 2, [1,21].
...
[Token 295] in Line 49, [1,22].With value 0
[Token 299] in Line 58, [0,0].
[Token 297] in Line 58, [1,39].
[Token 299] in Line 59, [0,0].
[Token 296] in Line 59, [1,93].With value 'this_is_a_definitely_way_too_long_ID_no_questions_'
~~~

- Igonore the nonsense tokens?

~~~cpp
int main(int argc, char **argv)
{
    // define the Scanner
    bool skip_nonsense_token = true;
    Scanner myScanner(stdin, skip_nonsense_token);

    // lex through the file
    while(myScanner.peek()->getTok() != END_OF_FILE){
        myScanner.next()->printTokenSummary();
    }
}
~~~

In this way, token types as `WS`, `COMMENT`, `END_OF_LINE`, `UNKNOWN` will be ignored.


## parser

The parser deals with the grammar. The parser accepts token streams from scanner and output a parse tree. It use the grammar defined in `boris.y`, which is a `bison` format document.

The parser is generated by using `bison`.

- Build the parser

~~~ bash
>> make parser
~~~

- Run tests

~~~bash
tests/p2test_input.sh     
~~~

The input will be parsed into a parse tree, and it can be visualized into the `stdout`.
~~~
> input:
global a = 1;
if a < 2 
    then print a;
end if

> stdout:
[ROOT_INPUT]
    [SDD_LIST]
        [DECL_AS_SDD]
            [GLOBAL_DECL]
                [PLACEHOLDER]261
                [ID]a
                [PLACEHOLDER]293
                [SINGLE_INT_AS_EXPR]
                    [INT]1
                [PLACEHOLDER]290
        [SDD_LIST]
            [STATEMENT_AS_SDD]
                [IF_STATEMENT]
                    [PLACEHOLDER]266
                    [BOOLEXPR]
                        [SINGLE_ID_AS_EXPR]
                            [ID]a
                        [PLACEHOLDER]278
                        [SINGLE_INT_AS_EXPR]
                            [INT]2
                    [PLACEHOLDER]267
                    [STATEMENT_LIST]
                        [PRINT_STATEMENT]
                            [PLACEHOLDER]274
                            [SINGLE_ID_AS_EXPR]
                                [ID]a
                            [PLACEHOLDER]290
                        [EMPTY_NODE]
                    [EMPTY_NODE]
                    [PLACEHOLDER]263
                    [PLACEHOLDER]266
            [EMPTY_NODE]
~~~

Here every `nonterminal` in the grammar will be constructed as a internal node in the parse tree and every `terminal` is a leaf node in parse tree.

The only four `terminal`s are:

- `NODETYPE_ID`: this node is designed for `ID` tokens and it will contain a char* value.
- `NODETYPE_INT`: this node is designed for `INT_LIT` tokens and it will contain a int value.
- `NODETYPE_PALCEHOLDERNODE`: this node is designed for the `keyword` and `operator`. It will contain the token number as identifier.
- `NODETYPE_EMPTY_NODE`: this is a `NULL` node.

All the `NODETYPE`s are defined in `boris.h`.