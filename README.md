# boris-compiler

> From NYU CS-UY3943 BK06/CS-GY6413: Compiler Design & Construction.

The project involves building several stages of a complete compiler for a made-up language made by Prof **Boris Aronov**. 


The following parts will be necessary:

- a scanner 
- a parser and symbol table handler
- a type checker
- a code generator

## scanner

The scanner (or to be mentioned as lexer) is used to use REGEX expression to recognize tokens in the input text.The scanner is generated by using `flex`.

- Build the scanner

~~~ bash
>> make scanner
~~~

- Run tests

~~~ bash
>> cat tests/p1test1.txt | ./boris_scanner >> tests/p1test1.out
~~~
~~~
position 43,1-43,3: [Lexer Error]INT_LIT in a invalid format. Non-zero integer can't start with 0. No guarantee what will happen.
position 47,1-47,22: [Lexer Error]The length of INT_LIT exceeds max length, No guarantee what will happen.
position 49,1-49,22: [Lexer Error]The length of INT_LIT exceeds max length, No guarantee what will happen.
position 59,1-59,93: [Lexer Error]ID length is too long. Will be truncted.
~~~
~~~ bash
>> cat tests/p1test1.out
~~~
~~~
token[258].[array] In position 4,1-4,5.
token[262].[defun] In position 5,1-5,5.
token[265].[do] In position 6,1-6,2.
token[269].[else] In position 7,1-7,4.
...
token[296].[this_is_a_definitely_way_too_long_ID_no_questions_about_it_yeah_yeah_yeah_yeah_yeah_yeah_yeah] In position 59,1-59,93.[ID] Retained infomation: yylval.sval=this_is_a_definitely_way_too_long_ID_no_questions_
~~~

## parser

The parser deals with the grammar. The parser accepts token streams from scanner and output a parse tree. It use the grammar defined in `boris.y`, which is a `bison` format document.

The parser is generated by using `bison`.

- Build the parser

~~~ bash
>> make parser
~~~

- Run tests

The input will be parsed into a parse tree, and it can be visualized into the `stdout`.
~~~ bash
>> cat tests/p2test0.txt | ./boris_parser 

Start parse tree visualization:

[ROOT_INPUT]
    [SDD_LIST]
        [STATEMENT_AS_SDD]
            [PRINT_STATEMENT]
                [PLACEHOLDER-274]print
                [SINGLE_INT_AS_EXPR]
                    [INT]131313
                [PLACEHOLDER-290];
        [EMPTY_NODE]
~~~


### Comments on the previous parse tree

According to the grammar. Input is a list of (statement|decl|defun). So the `ROOT_INPUT` node will be have a `SDD_LIST` as child. Then we only get one statement here, which is a `PRINT_STATEMENT` node. 

Inside `PRINT_STATEMENT` node, The `PLACEHOLDER` [274] is representing a keyword 'print', and `PLACEHOLDER` [290] is represnting a operator ';'.

The last `EMPTY_NODE` in last line is a node to note the end of `SDD_LIST`.

### General rules of the nodes in a parse tree

Here every `nonterminal` in the grammar will be constructed as a internal node in the parse tree and every `terminal` is a leaf node in parse tree.

The only four `terminal`s are:

- `ID`: this node is designed for `ID` tokens and it will contain a char* value.
- `INT`: this node is designed for `INT_LIT` tokens and it will contain a int value.
- `PALCEHOLDERNODE`: this node is designed for the `keyword` and `operator`. It will contain the token number as identifier.
- `EMPTY_NODE`: this is a `NULL` node.

All the `NODETYPE`s are defined in `boris.h`.
